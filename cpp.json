{
  "../library/algebra/combination.cpp": {
    "body": [
      "struct Combination {",
      "    vector<lint> fac, finv, inv;",
      "    Combination(lint maxN) : fac(maxN + 100), finv(maxN + 100), inv(maxN + 100) {",
      "        maxN += 100; // for safety",
      "        fac[0] = fac[1] = 1;",
      "        finv[0] = finv[1] = 1;",
      "        inv[1]            = 1;",
      "        for (lint i = 2; i <= maxN; ++i) {",
      "            fac[i]  = fac[i - 1] * i % mod;",
      "            inv[i]  = mod - inv[mod % i] * (mod / i) % mod;",
      "            finv[i] = finv[i - 1] * inv[i] % mod;",
      "        }",
      "    }",
      "    lint operator()(lint n, lint k) {",
      "        if (n < k)",
      "            return 0;",
      "        if (n < 0 || k < 0)",
      "            return 0;",
      "        return fac[n] * (finv[k] * finv[n - k] % mod) % mod;",
      "    }",
      "};"
    ],
    "prefix": "combination"
  },
  "../library/algebra/combinationprob.cpp": {
    "body": [
      "// calculates nCk / 2^n",
      "// https://www.slideshare.net/chokudai/abc011",
      "// editorial D",
      "struct CombinationProb {",
      "    vector<vector<long double>> fac;",
      "    CombinationProb(int maxN) {",
      "        fac.resize(maxN + 2, vector<long double>(maxN + 2, 0.0));",
      "        fac[0][0] = 1.0;",
      "        for (int i = 1; i <= maxN; ++i) {",
      "            fac[i][0] = fac[i - 1][0] / 2.0;",
      "            for (int j = 1; j <= i + 1; ++j) {",
      "                fac[i][j] = (fac[i - 1][j] + fac[i - 1][j - 1]) / 2.0;",
      "            }",
      "        }",
      "    }",
      "    long double operator()(int n, int k) { return fac[n][k]; }",
      "};"
    ],
    "prefix": "combinationprob"
  },
  "../library/algebra/eratosthenes.cpp": {
    "body": [
      "// Eratosthenes's sieve",
      "// create list of prime numbers in O(N)",
      "// check if the given number is prime in O(1)",
      "struct Sieve {",
      "    vector<bool> isPrime;",
      "    Sieve(size_t max) : isPrime(max + 1, true) {",
      "        isPrime[0] = false;",
      "        isPrime[1] = false;",
      "",
      "        for (size_t i = 2; i * i <= max; ++i)",
      "            if (isPrime[i])",
      "                for (size_t j = 2; i * j <= max; ++j)",
      "                    isPrime[i * j] = false;",
      "    }",
      "    bool operator()(size_t n) { return isPrime[n]; }",
      "};"
    ],
    "prefix": "eratosthenes"
  },
  "../library/algebra/factors.cpp": {
    "body": [
      "// list up all factors",
      "template <typename T>",
      "set<T> factors(T a) {",
      "    set<T> facs;",
      "    for (T i = 1; i * i <= a; ++i) {",
      "        if (a % i == 0) {",
      "            facs.insert(i);",
      "            facs.insert(a / i);",
      "        }",
      "    }",
      "    return facs;",
      "}"
    ],
    "prefix": "factors"
  },
  "../library/algebra/gcd.cpp": {
    "body": [
      "// greatest common divisor and least common multiple",
      "// gcd is calculated by Euclidean Algorithm",
      "// lcm = m * n / gcd(m,n)",
      "template <typename T = int>",
      "T gcd(T a, T b) {",
      "    if (a < b)",
      "        return gcd(b, a);",
      "    if (b == 0)",
      "        return a;",
      "    T r;",
      "    while ((r = a % b)) {",
      "        a = b;",
      "        b = r;",
      "    }",
      "    return b;",
      "}",
      "",
      "template <typename T = int>",
      "T lcm(T m, T n) {",
      "    if ((0 == m) || (0 == n))",
      "        return 0;",
      "    return ((m / gcd(m, n)) * n);",
      "}"
    ],
    "prefix": "gcd"
  },
  "../library/algebra/mint.cpp": {
    "body": [
      "struct mint {",
      "    lint v;",
      "    lint _mod;",
      "    mint() : v(0) {}",
      "    mint(signed v, lint _mod = mod) : v(v), _mod(_mod) {}",
      "    mint(lint t, lint _mod = mod) : _mod(_mod) {",
      "        v = t % _mod;",
      "        if (v < 0)",
      "            v += _mod;",
      "    }",
      "",
      "    mint pow(lint k) {",
      "        mint res(1), tmp(v);",
      "        while (k) {",
      "            if (k & 1)",
      "                res *= tmp;",
      "            tmp *= tmp;",
      "            k >>= 1;",
      "        }",
      "        return res;",
      "    }",
      "    static mint add_identity() { return mint(0); }",
      "    static mint mul_identity() { return mint(1); }",
      "    mint inv() { return pow(_mod - 2); }",
      "",
      "    mint &operator+=(mint a) {",
      "        v += a.v;",
      "        if (v >= _mod)",
      "            v -= _mod;",
      "        return *this;",
      "    }",
      "    mint &operator-=(mint a) {",
      "        v += _mod - a.v;",
      "        if (v >= _mod)",
      "            v -= _mod;",
      "        return *this;",
      "    }",
      "    mint &operator*=(mint a) {",
      "        v = v * a.v % _mod;",
      "        return *this;",
      "    }",
      "    mint &operator/=(mint a) { return (*this) *= a.inv(); }",
      "",
      "    mint operator+(mint a) const { return mint(v) += a; };",
      "    mint operator-(mint a) const { return mint(v) -= a; };",
      "    mint operator*(mint a) const { return mint(v) *= a; };",
      "    mint operator/(mint a) const { return mint(v) /= a; };",
      "",
      "    mint operator-() const { return v ? mint(_mod - v) : mint(v); }",
      "",
      "    bool operator==(const mint a) const { return v == a.v; }",
      "    bool operator!=(const mint a) const { return v != a.v; }",
      "    bool operator<(const mint a) const { return v < a.v; }",
      "};",
      "ostream &operator<<(ostream &os, mint m) { return os << m.v; }"
    ],
    "prefix": "mint"
  },
  "../library/algebra/primefactors.cpp": {
    "body": [
      "// list up all prime factors, including how many times does it have the prime",
      "template <typename T = int>",
      "void primeFactors(T a, map<T, int> &facs) {",
      "    double sqrtA = sqrt(a);",
      "    for (int i = 2; i <= sqrtA + 1e-10; ++i) {",
      "        while (a % i == 0) {",
      "            facs[i]++;",
      "            a /= i;",
      "        }",
      "    }",
      "    if (a > sqrtA)",
      "        facs[a]++;",
      "    return;",
      "}"
    ],
    "prefix": "primefactors"
  },
  "../library/datastructure/binaryindexedtree.cpp": {
    "body": [
      "// Binary Indexed Tree / Fenwick tree",
      "// calculate partial sum in O(logN)",
      "// update single datum in O(logN)",
      "// lower_bound is binary search O(logN)",
      "// 0-indexed!!!",
      "template <typename T = int>",
      "struct BinaryIndexedTree {",
      "    int n;",
      "    vector<T> bit;",
      "    BinaryIndexedTree(int n_) : n(n_), bit(n_ + 1, 0) {}",
      "    BinaryIndexedTree(vector<T> const &init) : n(init.size()), bit(init.size() + 1, 0) {",
      "        for (int i = 1; i <= n; ++i) {",
      "            bit[i] = init[i - 1];",
      "        }",
      "        for (int i = 1; i <= n; ++i) {",
      "            if (i + (i & -i) <= n)",
      "                bit[i + (i & -i)] += bit[i];",
      "        }",
      "    }",
      "    T sum(int i) {",
      "        i++;",
      "        T s = 0;",
      "        for (int x = i; x > 0; x -= (x & -x))",
      "            s += bit[x];",
      "        return s;",
      "    }",
      "    void add(int i, T a) {",
      "        i++;",
      "        if (i == 0)",
      "            return;",
      "        for (int x = i; x <= n; x += (x & -x))",
      "            bit[x] += a;",
      "    }",
      "    int lower_bound(int w) {",
      "        if (w <= 0)",
      "            return 0;",
      "        int x = 0, r = 1;",
      "        while (r < n)",
      "            r <<= 1;",
      "        for (int k = r; k > 0; k >>= 1) {",
      "            if (x + k <= n && bit[x + k] < w) {",
      "                w -= bit[x + k];",
      "                x += k;",
      "            }",
      "        }",
      "        return x + 1;",
      "    }",
      "    int upper_bound(int w) {",
      "        if (w < 0)",
      "            return 0;",
      "        int x = 0, r = 1;",
      "        while (r < n)",
      "            r <<= 1;",
      "        for (int k = r; k > 0; k >>= 1) {",
      "            if (x + k <= n && bit[x + k] <= w) {",
      "                w -= bit[x + k];",
      "                x += k;",
      "            }",
      "        }",
      "        return x + 1;",
      "    }",
      "    T query(int l, int r) { return sum(r - 1) - sum(l - 1); }",
      "};"
    ],
    "prefix": "binaryindexedtree"
  },
  "../library/datastructure/segmenttree.cpp": {
    "body": [
      "// 0-indexed bottom up Segment Tree",
      "// UNIT is the identity element of operation func",
      "template <typename T = int>",
      "struct SegmentTree {",
      "    using F = function<T(T, T)>;",
      "    int n;",
      "    vector<T> dat;",
      "    F func;",
      "    T UNIT;",
      "",
      "    SegmentTree(int n_, F func_, T UNIT_) : func(func_), UNIT(UNIT_) {",
      "        n = 1;",
      "        // full binary tree: num of leaves = n = 2^k >= n_",
      "        while (n < n_)",
      "            n *= 2;",
      "        dat.assign(2 * n - 1, UNIT);",
      "    }",
      "    SegmentTree(vector<T> v_, F func_, T UNIT_) : func(func_), UNIT(UNIT_) {",
      "        n      = 1;",
      "        int nv = v_.size();",
      "        while (n < nv)",
      "            n *= 2;",
      "        dat.assign(2 * n - 1, UNIT);",
      "        for (int i = 0; i < nv; ++i) {",
      "            dat[n - 1 + i] = v_[i];",
      "        }",
      "        for (int i = n - 2; i >= 0; --i) {",
      "            dat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);",
      "        }",
      "    }",
      "    void update(int k, T a) {",
      "        // leaves are at index n-1 to 2*n-2",
      "        k += n - 1;",
      "        dat[k] = a;",
      "        while (k > 0) {",
      "            // k -> parent node",
      "            k = (k - 1) / 2;",
      "            // func(child nodes)",
      "            dat[k] = func(dat[2 * k + 1], dat[2 * k + 2]);",
      "        }",
      "    }",
      "    // get result of func() in [l, r)",
      "    T query(int l, int r) {",
      "        l += n - 1;",
      "        r += n - 1;",
      "        T retl = UNIT, retr = UNIT;",
      "        while (l < r) {",
      "            if ((l & 1) == 0)",
      "                retl = func(retl, dat[l]);",
      "            if ((r & 1) == 0)",
      "                retr = func(dat[r - 1], retr);",
      "            l = l / 2;",
      "            r = (r - 1) / 2;",
      "        }",
      "        return func(retl, retr);",
      "    }",
      "};"
    ],
    "prefix": "segmenttree"
  },
  "../library/datastructure/segmenttreelazy.cpp": {
    "body": [
      "template <typename T = lint>",
      "struct SegmentTreeLazy {",
      "  private:",
      "    using F = function<T(T, T)>;",
      "    int n;",
      "    vector<T> node, lazy;",
      "    vector<bool> lazyFlag;",
      "    F func;",
      "    T unit;",
      "",
      "  public:",
      "    SegmentTreeLazy(int sz, F func, T unit) : func(func), unit(unit) {",
      "        n = 1;",
      "        while (n < sz)",
      "            n *= 2;",
      "        node.assign(2 * n - 1, unit);",
      "        lazy.assign(2 * n - 1, unit);",
      "        lazyFlag.resize(2 * n - 1, false);",
      "    }",
      "    SegmentTreeLazy(vector<T> v, F func, T unit) : func(func), unit(unit) {",
      "        int sz = int(v.size());",
      "        n      = 1;",
      "        while (n < sz)",
      "            n *= 2;",
      "        node.resize(2 * n - 1, unit);",
      "        lazy.resize(2 * n - 1, unit);",
      "        lazyFlag.resize(2 * n - 1, false);",
      "",
      "        for (int i = 0; i < sz; i++)",
      "            node[i + n - 1] = v[i];",
      "        for (int i = n - 2; i >= 0; i--)",
      "            node[i] = func(node[i * 2 + 1], node[i * 2 + 2]);",
      "    }",
      "    void lazyEvaluate(int k, int l, int r) {",
      "        if (lazyFlag[k]) {",
      "            node[k] = lazy[k];",
      "            if (r - l > 1) {",
      "                lazy[k * 2 + 1] = lazy[k * 2 + 2] = lazy[k];",
      "                lazyFlag[k * 2 + 1] = lazyFlag[k * 2 + 2] = true;",
      "            }",
      "            lazyFlag[k] = false;",
      "        }",
      "    }",
      "    // replace nodes with x in [a, b)",
      "    void update(int a, int b, T x, int k = 0, int l = 0, int r = -1) {",
      "        if (r < 0)",
      "            r = n;",
      "        lazyEvaluate(k, l, r);",
      "        if (b <= l || r <= a)",
      "            return;",
      "        if (a <= l && r <= b) {",
      "            lazy[k]     = x;",
      "            lazyFlag[k] = true;",
      "            lazyEvaluate(k, l, r);",
      "        } else {",
      "            const int mid = (l + r) / 2;",
      "            update(a, b, x, 2 * k + 1, l, mid);",
      "            update(a, b, x, 2 * k + 2, mid, r);",
      "            node[k] = func(node[2 * k + 1], node[2 * k + 2]);",
      "        }",
      "    }",
      "    // get func() in [a, b)",
      "    T query(int a, int b, int k = 0, int l = 0, int r = -1) {",
      "        if (r < 0)",
      "            r = n;",
      "        lazyEvaluate(k, l, r);",
      "        if (b <= l || r <= a)",
      "            return unit;",
      "        if (a <= l && r <= b)",
      "            return node[k];",
      "        T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);",
      "        T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);",
      "        return func(vl, vr);",
      "    }",
      "};"
    ],
    "prefix": "segmenttreelazy"
  },
  "../library/datastructure/segmenttreelazyadd.cpp": {
    "body": [
      "template <typename T = lint>",
      "struct SegmentTreeLazyAdd {",
      "  private:",
      "    using F = function<T(T, T)>;",
      "    using G = function<int(int, int)>;",
      "    int n;",
      "    vector<T> node, lazy, width;",
      "    vector<bool> lazyFlag;",
      "    F func;",
      "    G funcw;",
      "    T unit;",
      "",
      "  public:",
      "    SegmentTreeLazyAdd(int sz, F func, G funcw, T unit) : func(func), funcw(funcw), unit(unit) {",
      "        n = 1;",
      "        while (n < sz)",
      "            n *= 2;",
      "        node.assign(2 * n - 1, unit);",
      "        lazy.assign(2 * n - 1, 0);",
      "        lazyFlag.assign(2 * n - 1, false);",
      "        width.assign(2 * n - 1, 1);",
      "        for (int i = n - 2; i >= 0; --i) {",
      "            width[i] = funcw(width[i * 2 + 1], width[i * 2 + 2]);",
      "        }",
      "    }",
      "    SegmentTreeLazyAdd(vector<T> v, F func, G funcw, T unit) : func(func), funcw(funcw), unit(unit) {",
      "        int sz = int(v.size());",
      "        n      = 1;",
      "        while (n < sz)",
      "            n *= 2;",
      "        node.assign(2 * n - 1, unit);",
      "        lazy.assign(2 * n - 1, 0);",
      "        lazyFlag.assign(2 * n - 1, false);",
      "        for (int i = 0; i < sz; i++)",
      "            node[i + n - 1] = v[i];",
      "        for (int i = n - 2; i >= 0; i--)",
      "            node[i] = func(node[i * 2 + 1], node[i * 2 + 2]);",
      "        width.assign(2 * n - 1, 1);",
      "        for (int i = n - 2; i >= 0; --i) {",
      "            width[i] = funcw(width[i * 2 + 1], width[i * 2 + 2]);",
      "        }",
      "    }",
      "    void lazyEvaluate(int k, int l, int r) {",
      "        if (lazyFlag[k]) {",
      "            node[k] += lazy[k] * width[k];",
      "            if (r - l > 1) {",
      "                lazy[k * 2 + 1] += lazy[k];",
      "                lazy[k * 2 + 2] += lazy[k];",
      "                lazyFlag[k * 2 + 1] = lazyFlag[k * 2 + 2] = true;",
      "            }",
      "            lazyFlag[k] = false;",
      "            lazy[k]     = 0;",
      "        }",
      "    }",
      "    // add x to nodes in [a, b)",
      "    void add(int a, int b, T x, int k = 0, int l = 0, int r = -1) {",
      "        if (r < 0)",
      "            r = n;",
      "        lazyEvaluate(k, l, r);",
      "        if (b <= l || r <= a) {",
      "            return;",
      "        }",
      "        if (a <= l && r <= b) {",
      "            lazy[k] += x; // +=",
      "            lazyFlag[k] = true;",
      "            lazyEvaluate(k, l, r);",
      "            return;",
      "        } else {",
      "            const int mid = (l + r) / 2;",
      "            add(a, b, x, k * 2 + 1, l, mid);",
      "            add(a, b, x, k * 2 + 2, mid, r);",
      "            node[k] = func(node[2 * k + 1], node[2 * k + 2]);",
      "        }",
      "    }",
      "    // get func() in [a, b)",
      "    T query(int a, int b, int k = 0, int l = 0, int r = -1) {",
      "        if (r < 0)",
      "            r = n;",
      "        lazyEvaluate(k, l, r);",
      "        if (b <= l || r <= a)",
      "            return unit;",
      "        if (a <= l && r <= b)",
      "            return node[k];",
      "        T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);",
      "        T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);",
      "        return func(vl, vr);",
      "    }",
      "};"
    ],
    "prefix": "segmenttreelazyadd"
  },
  "../library/datastructure/slidemin.cpp": {
    "body": [
      "// return slide minimum",
      "// original sequense seq, slide width w",
      "// return [min[0,w), min[1,1+w), ...]",
      "template <typename T>",
      "vector<T> slideMin(const vector<T> &seq, int w) {",
      "    vector<T> ret;",
      "    ret.reserve(seq.size() - w);",
      "    deque<int> q;",
      "    int l(0), r(0), n(seq.size());",
      "    while (r < w) {",
      "        while (!q.empty() && seq[q.back()] >= seq[r])",
      "            q.pop_back();",
      "        q.push_back(r++);",
      "    }",
      "    ret.push_back(seq[q.front()]);",
      "    while (r < n) {",
      "        while (!q.empty() && seq[q.back()] >= seq[r])",
      "            q.pop_back();",
      "        q.push_back(r++);",
      "        if (q.front() == l++)",
      "            q.pop_front();",
      "        ret.push_back(seq[q.front()]);",
      "    }",
      "    return ret;",
      "}"
    ],
    "prefix": "slidemin"
  },
  "../library/datastructure/unionfind.cpp": {
    "body": [
      "struct UnionFind {",
      "    vector<int> rank, parent, size;",
      "",
      "    // +1 for 1-indexed nodes",
      "    UnionFind(int n) : rank(n + 1, 0), parent(n + 1), size(n + 1, 1) {",
      "        iota(parent.begin(), parent.end(), 0); // parent is itself",
      "    }",
      "    int root(int x) {",
      "        if (x != parent[x]) {",
      "            parent[x] = root(parent[x]);",
      "        }",
      "        return parent[x];",
      "    }",
      "    bool isSame(int x, int y) { return root(x) == root(y); }",
      "    bool unite(int x, int y) { return link(root(x), root(y)); }",
      "    bool link(int x, int y) {",
      "        if (x == y)",
      "            return false;",
      "        if (rank[x] > rank[y]) {",
      "            parent[y] = x;",
      "            size[x] += size[y];",
      "        } else {",
      "            parent[x] = y;",
      "            size[y] += size[x];",
      "            if (rank[x] == rank[y]) {",
      "                rank[y]++;",
      "            }",
      "        }",
      "        return true;",
      "    }",
      "    int getSize(int x) { return size[root(x)]; }",
      "};"
    ],
    "prefix": "unionfind"
  },
  "../library/datastructure/unionfindpotential.cpp": {
    "body": [
      "template <class Abel>",
      "struct UnionFindPotential {",
      "    vector<int> parent, rank;",
      "    vector<Abel> diff_weight;",
      "",
      "    UnionFindPotential(int n = 1, Abel SUM_UNITY = 0)",
      "        : parent(n + 1), rank(n + 1, 0), diff_weight(n + 1, SUM_UNITY) {",
      "        iota(parent.begin(), parent.end(), 0);",
      "    }",
      "    int root(int x) {",
      "        if (parent[x] == x) {",
      "            return x;",
      "        } else {",
      "            int r = root(parent[x]);",
      "            diff_weight[x] += diff_weight[parent[x]];",
      "            return parent[x] = r;",
      "        }",
      "    }",
      "    Abel weight(int x) {",
      "        root(x);",
      "        return diff_weight[x];",
      "    }",
      "    bool isSame(int x, int y) { return root(x) == root(y); }",
      "    bool unite(int x, int y, Abel w) {",
      "        w += weight(x);",
      "        w -= weight(y);",
      "        x = root(x);",
      "        y = root(y);",
      "        if (x == y)",
      "            return false;",
      "        if (rank[x] < rank[y])",
      "            swap(x, y), w = -w;",
      "        if (rank[x] == rank[y])",
      "            ++rank[x];",
      "        parent[y] = x;",
      "        diff_weight[y] = w;",
      "        return true;",
      "    }",
      "    Abel diff(int x, int y) { return weight(y) - weight(x); }",
      "};"
    ],
    "prefix": "unionfindpotential"
  },
  "../library/flow/dinic.cpp": {
    "body": [
      "// ref: https://github.com/beet-aizu/library/blob/master/flow/dinic.cpp",
      "template <typename T, bool directed>",
      "struct Dinic {",
      "    struct edge {",
      "        int to;",
      "        T cap;   // capacity of the edge",
      "        int rev; // index for to->from edge",
      "        edge() {}",
      "        edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}",
      "    };",
      "    T inf = numeric_limits<T>::max();",
      "    vector<vector<edge>> G;",
      "    vector<int> level, iter;",
      "    Dinic(int n) : G(n), level(n), iter(n) {}",
      "",
      "    void addEdge(int from, int to, T cap) {",
      "        G[from].emplace_back(to, cap, G[to].size());",
      "        G[to].emplace_back(from, directed ? 0 : cap, G[from].size() - 1);",
      "    }",
      "    void bfs(int s) {",
      "        fill(level.begin(), level.end(), -1);",
      "        queue<int> que;",
      "        level[s] = 0;",
      "        que.emplace(s);",
      "        while (!que.empty()) {",
      "            int v = que.front();",
      "            que.pop();",
      "            for (edge &e : G[v]) {",
      "                if (e.cap > 0 && level[e.to] < 0) {",
      "                    level[e.to] = level[v] + 1;",
      "                    que.emplace(e.to);",
      "                }",
      "            }",
      "        }",
      "    }",
      "    T dfs(int v, int t, T f) {",
      "        if (v == t)",
      "            return f;",
      "        for (int i = iter[v]; i < int(G[v].size()); ++i) {",
      "            edge &e = G[v][i];",
      "            if (e.cap > 0 && level[v] < level[e.to]) {",
      "                T d = dfs(e.to, t, min(f, e.cap));",
      "                if (d == 0)",
      "                    continue;",
      "                e.cap -= d;",
      "                G[e.to][e.rev].cap += d;",
      "                return d;",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "    T maxFlow(int s, int t, T lim) {",
      "        T fl = 0;",
      "        while (true) {",
      "            bfs(s);",
      "            if (level[t] < 0 || lim == 0)",
      "                break;",
      "            fill(iter.begin(), iter.end(), 0);",
      "            while (true) {",
      "                T f = dfs(s, t, lim);",
      "                if (f == 0)",
      "                    break;",
      "                fl += f;",
      "                lim -= f;",
      "            }",
      "        }",
      "        return fl;",
      "    }",
      "    // returns maximum flow from s to t",
      "    T maxFlow(int s, int t) { return maxFlow(s, t, inf); }",
      "};"
    ],
    "prefix": "dinic"
  },
  "../library/graph/bellmanford.cpp": {
    "body": [
      "template <typename T> // T : type of cost",
      "struct BellmanFord {",
      "    T inf = numeric_limits<T>::max(); // initial value, reused when clear() is called",
      "    int n;                            // number of nodes",
      "    vector<bool> negative;",
      "    vector<T> dist; // distance from start node",
      "    struct edge {",
      "        int from, to;",
      "        T cost;",
      "        edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}",
      "    };",
      "    vector<edge> edges;",
      "",
      "    BellmanFord(int n) : n(n), negative(n, false), dist(n, inf){};",
      "",
      "    // 0-indexed!",
      "    void addEdge(int from, int to, T cost) { edges.emplace_back(from, to, cost); }",
      "",
      "    // calculate dist[i] as a shortest distance from start to each node",
      "    void build(int start) {",
      "        dist[start] = 0;",
      "        for (int i = 0; i < n; ++i) {",
      "            for (auto &e : edges) {",
      "                if (dist[e.from] != inf && dist[e.to] > dist[e.from] + e.cost) {",
      "                    dist[e.to] = dist[e.from] + e.cost;",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    // check whether there are negative cycles along the path of interest",
      "    bool hasNegativeCycle(int end = -1) {",
      "        for (int i = 0; i < n; ++i) {",
      "            for (auto &e : edges) {",
      "                if (dist[e.from] != inf && dist[e.to] > dist[e.from] + e.cost) {",
      "                    dist[e.to]     = dist[e.from] + e.cost;",
      "                    negative[e.to] = true;",
      "                }",
      "                negative[e.to] = negative[e.to] | negative[e.from];",
      "            }",
      "        }",
      "        if (end != -1)",
      "            return negative[end];",
      "        else {",
      "            bool neg = false;",
      "            for (int i = 0; i < n; ++i) {",
      "                neg = neg | negative[i];",
      "            }",
      "            return neg;",
      "        }",
      "    }",
      "};"
    ],
    "prefix": "bellmanford"
  },
  "../library/graph/dijkstra.cpp": {
    "body": [
      "template <typename T>",
      "vector<T> dijkstra(int s, vector<vector<pair<int, T>>> &G) {",
      "    const T inf = numeric_limits<T>::max();",
      "    using P     = pair<T, int>;",
      "    int n       = G.size();",
      "    vector<T> d(n, inf);",
      "    priority_queue<P, vector<P>, greater<P>> q;",
      "    d[s] = 0;",
      "    q.emplace(d[s], s);",
      "    while (!q.empty()) {",
      "        P p = q.top();",
      "        q.pop();",
      "        int v = p.second;",
      "        if (d[v] < p.first)",
      "            continue;",
      "        for (auto &e : G[v]) {",
      "            int u = e.first;",
      "            T c   = e.second;",
      "            if (d[u] > d[v] + c) {",
      "                d[u] = d[v] + c;",
      "                q.emplace(d[u], u);",
      "            }",
      "        }",
      "    }",
      "    return d;",
      "}"
    ],
    "prefix": "dijkstra"
  },
  "../library/graph/dijkstrarestore.cpp": {
    "body": [
      "template <typename T>",
      "struct Dijkstra {",
      "    using P = pair<T, int>;",
      "    int n;",
      "    T inf;",
      "    vector<T> dist;",
      "    vector<int> rev;",
      "    vector<vector<pair<int, T>>> G;",
      "",
      "    Dijkstra(vector<vector<pair<int, T>>> &G_) : G(G_) {",
      "        n   = G.size();",
      "        inf = numeric_limits<T>::max();",
      "    }",
      "    void build(int s) {",
      "        dist.clear();",
      "        dist.resize(n, inf);",
      "        rev.clear();",
      "        rev.resize(n, -1);",
      "        priority_queue<P, vector<P>, greater<P>> q;",
      "        dist[s] = 0;",
      "        q.emplace(dist[s], s);",
      "        while (!q.empty()) {",
      "            P p = q.top();",
      "            q.pop();",
      "            int v = p.second;",
      "            if (dist[v] < p.first)",
      "                continue;",
      "            for (auto &e : G[v]) {",
      "                int u = e.first;",
      "                T c   = e.second;",
      "                if (dist[u] > dist[v] + c) {",
      "                    dist[u] = dist[v] + c;",
      "                    rev[u]  = v;",
      "                    q.emplace(dist[u], u);",
      "                }",
      "            }",
      "        }",
      "    }",
      "    vector<int> restore_path(int t) {",
      "        vector<int> path;",
      "        for (; t != -1; t = rev[t])",
      "            path.push_back(t);",
      "        reverse(path.begin(), path.end());",
      "        return path;",
      "    }",
      "};"
    ],
    "prefix": "dijkstrarestore"
  },
  "../library/graph/topologicalsort.cpp": {
    "body": [
      "// topologically sort the directed graph",
      "// 0-indexed",
      "struct TopologicalSort {",
      "    int n;",
      "    vector<set<int>> G;",
      "    vector<bool> used;",
      "    vector<int> indeg, p;",
      "",
      "    TopologicalSort(int size) : n(size), G(n), used(n), indeg(n), p(0) {}",
      "",
      "    void addEdge(int s, int t) { G[s].insert(t); }",
      "    void bfs(int s) {",
      "        queue<int> q;",
      "        q.push(s);",
      "        used[s] = 1;",
      "        while (!q.empty()) {",
      "            int v = q.front();",
      "            q.pop();",
      "            p.push_back(v);",
      "            for (int u : G[v]) {",
      "                indeg[u]--;",
      "                if (indeg[u] == 0 && !used[u]) {",
      "                    used[u] = 1;",
      "                    q.push(u);",
      "                }",
      "            }",
      "        }",
      "    }",
      "    // returns topologically sorted nodes",
      "    // if p.size() < n, the graph cannot be sorted",
      "    vector<int> build() {",
      "        fill(used.begin(), used.end(), 0);",
      "        fill(indeg.begin(), indeg.end(), 0);",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int v : G[i])",
      "                indeg[v]++;",
      "        }",
      "        for (int i = 0; i < n; ++i) {",
      "            if (indeg[i] == 0 && !used[i])",
      "                bfs(i);",
      "        }",
      "        return p;",
      "    }",
      "};"
    ],
    "prefix": "topologicalsort"
  },
  "../library/graph/warshallfloyd.cpp": {
    "body": [
      "// dist is adjacency matrix, no edge = inf",
      "template <typename T, bool has_negative_edge = false>",
      "void warshallFloyd(vector<vector<T>> &dist, T inf) {",
      "    int n = dist.size();",
      "    for (int i = 0; i < n; ++i) {",
      "        for (int j = 0; j < n; ++j) {",
      "            for (int k = 0; k < n; ++k) {",
      "                if (has_negative_edge) {",
      "                    if (dist[j][i] != inf && dist[i][k] != inf)",
      "                        chmin(dist[j][k], dist[j][i] + dist[i][k]);",
      "                } else {",
      "                    chmin(dist[j][k], dist[j][i] + dist[i][k]);",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "prefix": "warshallfloyd"
  },
  "../library/string/rollinghash.cpp": {
    "body": [
      "// original: https://qiita.com/keymoon/items/11fac5627672a6d6a9f6",
      "class RollingHash {",
      "  private:",
      "    using ulint                        = unsigned long long;",
      "    static constexpr ulint mask30      = (1ULL << 30) - 1;",
      "    static constexpr ulint mask31      = (1ULL << 31) - 1;",
      "    static constexpr ulint mod         = (1ULL << 61) - 1;",
      "    static constexpr ulint positivizer = mod * ((1ULL << 3) - 1);",
      "    static constexpr unsigned int base = 1033;",
      "    int len;",
      "    std::vector<ulint> pow_b, hash;",
      "    static ulint mul(ulint l, ulint r) {",
      "        const ulint lu        = l >> 31;",
      "        const ulint ld        = l & mask31;",
      "        const ulint ru        = r >> 31;",
      "        const ulint rd        = r & mask31;",
      "        const ulint middleBit = ld * ru + lu * rd;",
      "        return ((lu * ru) << 1) + ld * rd + ((middleBit & mask30) << 31) + (middleBit >> 30);",
      "    }",
      "    static ulint calcMod(ulint val) {",
      "        val = (val & mod) + (val >> 61);",
      "        if (val > mod)",
      "            val -= mod;",
      "        return val;",
      "    }",
      "",
      "  public:",
      "    template <typename T>",
      "    RollingHash(const T &s) : len(s.size()), pow_b(s.size() + 1), hash(s.size() + 1) {",
      "        pow_b[0] = 1;",
      "        hash[0]  = 1;",
      "        for (int i = 0; i < len; ++i) {",
      "            pow_b[i + 1] = calcMod(mul(pow_b[i], base));",
      "            hash[i + 1]  = calcMod(mul(hash[i], base) + s[i]);",
      "        }",
      "    }",
      "    // hash for [l, r)",
      "    ulint get(int l, int r) const { return calcMod(hash[r] + positivizer - mul(hash[l], pow_b[r - l])); }",
      "    // length of longest common prefix",
      "    int lcp(const RollingHash &rhs, int l1, int r1, int l2, int r2) const {",
      "        int lb = 0, ub = std::min(r1 - l1, r2 - l2) + 1;",
      "        while (ub - lb > 1) {",
      "            const int md                                         = (lb + ub) >> 1;",
      "            (get(l1, l1 + md) == rhs.get(l2, l2 + md) ? lb : ub) = md;",
      "        }",
      "        return lb;",
      "    }",
      "};"
    ],
    "prefix": "rollinghash"
  },
  "../library/string/zalgorithm.cpp": {
    "body": [
      "template <typename T>",
      "vector<int> ZAlgorithm(const T &s) {",
      "    const int ns = s.size();",
      "    vector<int> prefix(ns);",
      "    for (int i = 1, j = 0; i < ns; i++) {",
      "        if (i + prefix[i - j] < j + prefix[j]) {",
      "            prefix[i] = prefix[i - j];",
      "        } else {",
      "            int k = max(0, j + prefix[j] - i);",
      "            while (i + k < ns && s[k] == s[i + k])",
      "                ++k;",
      "            prefix[i] = k;",
      "            j         = i;",
      "        }",
      "    }",
      "    prefix[0] = ns;",
      "    return prefix;",
      "}"
    ],
    "prefix": "zalgorithm"
  },
  "../library/tree/kruskal.cpp": {
    "body": [
      "struct UnionFind {",
      "    vector<int> rank, parent, size;",
      "",
      "    // +1 for 1-indexed nodes",
      "    UnionFind(int n) : rank(n + 1, 0), parent(n + 1), size(n + 1, 1) {",
      "        iota(parent.begin(), parent.end(), 0); // parent is itself",
      "    }",
      "    int root(int x) {",
      "        if (x != parent[x]) {",
      "            parent[x] = root(parent[x]);",
      "        }",
      "        return parent[x];",
      "    }",
      "    bool isSame(int x, int y) { return root(x) == root(y); }",
      "    bool unite(int x, int y) { return link(root(x), root(y)); }",
      "    bool link(int x, int y) {",
      "        if (x == y)",
      "            return false;",
      "        if (rank[x] > rank[y]) {",
      "            parent[y] = x;",
      "            size[x] += size[y];",
      "        } else {",
      "            parent[x] = y;",
      "            size[y] += size[x];",
      "            if (rank[x] == rank[y]) {",
      "                rank[y]++;",
      "            }",
      "        }",
      "        return true;",
      "    }",
      "    int getSize(int x) { return size[root(x)]; }",
      "};",
      "",
      "// Kruskal algorithm: build minimum spanning tree",
      "template <typename T>",
      "struct Kruskal {",
      "    struct edge {",
      "        int from, to, used;",
      "        T cost;",
      "        edge(int from_, int to_, T cost_) : from(from_), to(to_), used(0), cost(cost_) {}",
      "        bool operator<(const edge &e) const { return cost < e.cost; }",
      "    };",
      "    vector<edge> es;",
      "    UnionFind uf;",
      "    Kruskal(int n) : uf(n + 1) {}",
      "    void addEdge(int f, int t, T c) { es.emplace_back(f, t, c); }",
      "    T build() {",
      "        sort(es.begin(), es.end());",
      "        T res = 0;",
      "        for (auto &e : es) {",
      "            if (!uf.isSame(e.from, e.to)) {",
      "                res += e.cost;",
      "                uf.unite(e.from, e.to);",
      "                e.used = 1;",
      "            }",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "prefix": "kruskal"
  },
  "../library/tree/lca.cpp": {
    "body": [
      "// 0-indexed bottom up Segment Tree",
      "// UNIT is the identity element of operation func",
      "template <typename T = int>",
      "struct SegmentTree {",
      "    using F = function<T(T, T)>;",
      "    int n;",
      "    vector<T> dat;",
      "    F func;",
      "    T UNIT;",
      "",
      "    SegmentTree(int n_, F func_, T UNIT_) : func(func_), UNIT(UNIT_) {",
      "        n = 1;",
      "        // full binary tree: num of leaves = n = 2^k >= n_",
      "        while (n < n_)",
      "            n *= 2;",
      "        dat.assign(2 * n - 1, UNIT);",
      "    }",
      "    SegmentTree(vector<T> v_, F func_, T UNIT_) : func(func_), UNIT(UNIT_) {",
      "        n      = 1;",
      "        int nv = v_.size();",
      "        while (n < nv)",
      "            n *= 2;",
      "        dat.assign(2 * n - 1, UNIT);",
      "        for (int i = 0; i < nv; ++i) {",
      "            dat[n - 1 + i] = v_[i];",
      "        }",
      "        for (int i = n - 2; i >= 0; --i) {",
      "            dat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);",
      "        }",
      "    }",
      "    void update(int k, T a) {",
      "        // leaves are at index n-1 to 2*n-2",
      "        k += n - 1;",
      "        dat[k] = a;",
      "        while (k > 0) {",
      "            // k -> parent node",
      "            k = (k - 1) / 2;",
      "            // func(child nodes)",
      "            dat[k] = func(dat[2 * k + 1], dat[2 * k + 2]);",
      "        }",
      "    }",
      "    // get result of func() in [l, r)",
      "    T query(int l, int r) {",
      "        l += n - 1;",
      "        r += n - 1;",
      "        T retl = UNIT, retr = UNIT;",
      "        while (l < r) {",
      "            if ((l & 1) == 0)",
      "                retl = func(retl, dat[l]);",
      "            if ((r & 1) == 0)",
      "                retr = func(dat[r - 1], retr);",
      "            l = l / 2;",
      "            r = (r - 1) / 2;",
      "        }",
      "        return func(retl, retr);",
      "    }",
      "};",
      "",
      "// get LCA on the tree",
      "// constructor: n = size of the graph",
      "// addEdge:",
      "// build: after adding all edge, build Euler tour and seg tree",
      "struct LCA {",
      "    int n;",
      "    int k;",
      "    vector<int> depth;",
      "    vector<int> eulerTour;",
      "    vector<int> firstVisit;",
      "    vector<vector<int>> edges;",
      "    SegmentTree<pair<int, int>> segTree;",
      "    static pair<int, int> pairComp(pair<int, int> a, pair<int, int> b) {",
      "        if (a.first < b.first)",
      "            return a;",
      "        else",
      "            return b;",
      "    }",
      "    LCA(int n)",
      "        : n(n), k(0), depth(2 * n - 1), eulerTour(2 * n - 1), firstVisit(n), edges(n),",
      "          segTree(2 * n, pairComp, make_pair(numeric_limits<int>::max(), 0)){};",
      "    void addEdge(int from, int to) {",
      "        edges[from].push_back(to);",
      "        edges[to].push_back(from);",
      "    }",
      "    void dfs(int curr = 0, int par = -1, int d = 0) {",
      "        firstVisit[curr] = k;",
      "        eulerTour[k]     = curr;",
      "        depth[k++]       = d;",
      "        for (auto &e : edges[curr]) {",
      "            if (e != par) {",
      "                dfs(e, curr, d + 1);",
      "                eulerTour[k] = curr;",
      "                depth[k++]   = d;",
      "            }",
      "        }",
      "    }",
      "    void build(int root = 0) {",
      "        dfs(root);",
      "        for (int i = 0; i < 2 * n - 1; ++i) {",
      "            segTree.update(i, make_pair(depth[i], eulerTour[i]));",
      "        }",
      "    }",
      "    // return LCA node of l and r",
      "    int operator()(int l, int r) {",
      "        int left  = firstVisit[l];",
      "        int right = firstVisit[r];",
      "        if (left > right)",
      "            swap(left, right);",
      "        return segTree.query(left, right + 1).second;",
      "    }",
      "    int getDepth(int k) { return depth[firstVisit[k]]; }",
      "};"
    ],
    "prefix": "lca"
  },
  "../snippets/all.cpp": {
    "body": [
      "$1.begin(), $1.end()"
    ],
    "prefix": "all"
  },
  "../snippets/arrayshuffle.cpp": {
    "body": [
      "template <typename T>",
      "void array_shuffle(vector<T> &arr) {",
      "    srand((unsigned int)(time(nullptr)));",
      "    int size = arr.size();",
      "    for (int i = size; i >= 1; --i) {",
      "        swap(arr[i - 1], arr[rand() % i]);",
      "    }",
      "}"
    ],
    "prefix": "arrayshuffle"
  },
  "../snippets/bisect.cpp": {
    "body": [
      "lint ok    = 0;",
      "lint ng    = inf;",
      "auto check = [&](lint mid) {",
      "",
      "};",
      "while (abs(ok - ng) != 1) {",
      "    lint mid               = (ok + ng) / 2;",
      "    (check(mid) ? ok : ng) = mid;",
      "}",
      "cout << ok << \"\\n\";"
    ],
    "prefix": "bisect"
  },
  "../snippets/chmin.cpp": {
    "body": [
      "template <class T>",
      "bool chmax(T &a, const T &b) {",
      "    return (a < b) ? (a = b, 1) : 0;",
      "}",
      "template <class T>",
      "bool chmin(T &a, const T &b) {",
      "    return (b < a) ? (a = b, 1) : 0;",
      "}"
    ],
    "prefix": "chmin"
  },
  "../snippets/cout.cpp": {
    "body": [
      "cout << $1 << \"\\n\";"
    ],
    "prefix": "cout"
  },
  "../snippets/dx4.cpp": {
    "body": [
      "const int dx[4] = {-1, 1, 0, 0};",
      "const int dy[4] = {0, 0, -1, 1};"
    ],
    "prefix": "dx4"
  },
  "../snippets/for.cpp": {
    "body": [
      "for (int $1 = 0; $1 < $2; ++$1) {",
      "    $0",
      "}"
    ],
    "prefix": "for"
  },
  "../snippets/forea.cpp": {
    "body": [
      "for (auto &$1 : $2) {",
      "    $0",
      "}"
    ],
    "prefix": "forea"
  },
  "../snippets/forr.cpp": {
    "body": [
      "for (int $1 = $2; $1 >= 0; --$1) {",
      "    $0",
      "}"
    ],
    "prefix": "forr"
  },
  "../snippets/forrit.cpp": {
    "body": [
      "for (auto it = $1.rbegin(); it != $1.rend(); it = next(it)) {",
      "    $0",
      "}"
    ],
    "prefix": "forrit"
  },
  "../snippets/inside.cpp": {
    "body": [
      "auto inside = [&](int y, int x) { return 0 <= y && y < h && 0 <= x && x < w; };"
    ],
    "prefix": "inside"
  },
  "../snippets/main.cpp": {
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using lint     = long long;",
      "const lint inf = 1LL << 60;",
      "const lint mod = 1000000007;",
      "",
      "int main() {",
      "    cin.tie(nullptr);",
      "    ios::sync_with_stdio(false);",
      "    $0;",
      "    return 0;",
      "}"
    ],
    "prefix": "main"
  },
  "../snippets/orderedstruct.cpp": {
    "body": [
      "struct ${1:name} {",
      "    int ${2:a}, ${3:b};",
      "    bool operator<(const ${1:name} &rhs) const { return ${2:a} < rhs.${2:a}; };",
      "};"
    ],
    "prefix": "orderedstruct"
  },
  "../snippets/sort.cpp": {
    "body": [
      "sort($1.begin(), $1.end()%2);"
    ],
    "prefix": "sort"
  },
  "../snippets/uniq.cpp": {
    "body": [
      "sort($1.begin(), $1.end());",
      "$1.erase(unique($1.begin(), $1.end()), $1.end());"
    ],
    "prefix": "uniq"
  }
}